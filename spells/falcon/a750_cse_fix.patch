diff --git a/src/freedreno/ir3/ir3_cse_a750.c b/src/freedreno/ir3/ir3_cse_a750.c
new file mode 100644
index 0000000..5555555
--- /dev/null
+++ b/src/freedreno/ir3/ir3_cse_a750.c
@@
+/*
+ * A750-specific adjustments for IR3 CSE
+ * - Enable MOV and META_COLLECT CSE safely
+ * - Handle SSA defs to avoid hangchecks
+ */
+
+static bool
+instr_can_cse_a750(const struct ir3_instruction *instr)
+{
+    if (instr->opc != OPC_META_COLLECT && instr->opc != OPC_MOV)
+        return false;
+
+    if ((instr->dsts[0]->flags & IR3_REG_ARRAY) &&
+        !(instr->dsts[0]->flags & IR3_REG_SSA))
+        return false;
+
+    if (!is_dest_gpr(instr->dsts[0]))
+        return false;
+
+    return true;
+}
+
+bool ir3_cse_a750(struct ir3 *ir)
+{
+    struct set *instr_set = _mesa_set_create(NULL, hash_instr, cmp_func);
+    foreach_block (block, &ir->block_list) {
+        _mesa_set_clear(instr_set, NULL);
+
+        foreach_instr (instr, &block->instr_list) {
+            instr->data = NULL;
+            if (!instr_can_cse_a750(instr))
+                continue;
+
+            bool found;
+            struct set_entry *entry =
+                _mesa_set_search_or_add(instr_set, instr, &found);
+            if (found)
+                instr->data = (void *)entry->key;
+        }
+    }
+
+    bool progress = false;
+    foreach_block (block, &ir->block_list) {
+        foreach_instr (instr, &block->instr_list) {
+            foreach_src (src, instr) {
+                if ((src->flags & IR3_REG_SSA) && src->def &&
+                    src->def->instr->data) {
+                    progress = true;
+                    struct ir3_instruction *instr = src->def->instr->data;
+                    src->def = instr->dsts[0];
+                }
+            }
+        }
+    }
+
+    _mesa_set_destroy(instr_set, NULL);
+    return progress;
+}
